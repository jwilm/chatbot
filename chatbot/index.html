<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `chatbot` crate.">
    <meta name="keywords" content="rust, rustlang, rust-lang, chatbot">

    <title>chatbot - Rust</title>

    <link rel="stylesheet" type="text/css" href="../main.css">

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'></p><script>window.sidebarCurrent = {name: 'chatbot', ty: 'mod', relpath: '../'};</script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'><span class='in-band'>Crate <a class='mod' href=''>chatbot</a></span><span class='out-of-band'><span id='render-detail'>
            <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                [<span class='inner'>&#x2212;</span>]
            </a>
        </span><a id='src-0' class='srclink' href='../src/chatbot/lib.rs.html#1-146' title='goto source code'>[src]</a></span></h1>
<div class='docblock'><p>An extensible platform for writing chatbots.</p>

<p>Chatbot is extensible in both adapters (services it connects to like IRC or Slack) and handlers
(the bits of code processing messages). Several adapters are provided out of the box including a
<a href="adapter/struct.CliAdapter.html">Command-line Adapter</a>, an <a href="adapter/struct.CliAdapter.html">IRC Adapter</a>, and a <a href="adapter/struct.SlackAdapter.html">Slack Adapter</a>. There&#39;s also several
handlers built in which can be viewed in the <a href="handler/trait.MessageHandler.html#implementors">implementors</a> section
of the handler module.</p>

<p><code>cargo run</code> will get you a working command line bot immediately after cloning. The <code>main.rs</code>
file is the default binary and is a good starting place to hack on your own bot.</p>

<h2 id="adapters" class='section-header'><a
                           href="#adapters">Adapters</a></h2>
<p>An adapter is a wrapper around some service like Slack, IRC, or just the command line. When the
bot starts up, it passes a Sender<IncomingMessage> into the handler <code>process_events</code> method.
The main loop owns the receiver and thus gets messages from all of the adapters. When the
adapter gets a message from the underlying service, it must create an IncomingMessage and <code>send</code>
it using that Sender. The IncomingMessage must be populated with a <code>Sender&lt;OutgoingMessage&gt;</code>
which the adapter calls <code>recv</code> on. It is up to the adapter what to do with these
OutgoingMessages. Generally they should be directed to whence they came.</p>

<h2 id="handlers" class='section-header'><a
                           href="#handlers">Handlers</a></h2>
<p>Handlers provide a <code>Regex</code> which the main loop uses to check whether the handler is interested.
If the regex matches, <code>handle</code> is called on the handler with the IncomingMessage. The handler
can then do some work and call <code>reply</code> on the incoming message to send its response. The adapter
which created the incoming message will decide how to route the message back to the service.</p>

<p>Handlers are not sandboxed and can thus bring the bot down in flames if they decide to panic. It
may be worth sandboxing in threads in the future (maybe make handlers <code>Runnable</code> and send to a
worker pool). The built in handlers are written with care as to not panic the bot.</p>

<p>For very simple handlers, there is a <code>handler!</code> macro which lets you pass a regex and a closure
without having to implement the MessageHandler trait. The example below contains an example of
this.</p>

<h2 id="chatbot" class='section-header'><a
                           href="#chatbot">Chatbot</a></h2>
<p>The Chatbot is the central data structure of the chatbot platform. It contains a <code>run</code> method
which listens for messages from adapters and routes them to handlers. Any program which uses
chatbot will need to minimally create a Chatbot, add an adapter, add a handler, and call Chatbot
<a href="chatbot/struct.Chatbot.html#method.run"><code>run</code></a>.</p>

<p>For example, setting up a simple echo server that responds to CLI input:</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>chatbot</span>::<span class='ident'>Chatbot</span>;
<span class='kw'>use</span> <span class='ident'>chatbot</span>::<span class='ident'>adapter</span>::<span class='ident'>CliAdapter</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>bot</span> <span class='op'>=</span> <span class='ident'>Chatbot</span>::<span class='ident'>new</span>(<span class='string'>&quot;echobot&quot;</span>);

<span class='kw'>let</span> <span class='ident'>echo</span> <span class='op'>=</span> <span class='macro'>handler</span><span class='macro'>!</span>(<span class='string'>&quot;EchoHandler&quot;</span>, <span class='string'>r&quot;echo .+&quot;</span>, <span class='op'>|</span>_, <span class='ident'>msg</span><span class='op'>|</span> {
    <span class='prelude-val'>Some</span>(<span class='ident'>msg</span>.<span class='ident'>to_owned</span>())
});

<span class='ident'>bot</span>.<span class='ident'>add_handler</span>(<span class='ident'>echo</span>);
<span class='ident'>bot</span>.<span class='ident'>add_adapter</span>(<span class='ident'>CliAdapter</span>::<span class='ident'>new</span>());

<span class='ident'>bot</span>.<span class='ident'>run</span>();</pre>

<p>Sometimes you might want the bot to react only when it is addressed,
this is what
<a href="chatbot/struct.Chatbot.html#method.add_addressed_handler"><code>add_addressed_handler</code></a> is for.</p>

<p>An example would be a bot that responses to pings, only you don&#39;t want the bot to respond
everytime there is any form of &quot;ping&quot; in a sentence.</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>chatbot</span>::<span class='ident'>Chatbot</span>;
<span class='kw'>use</span> <span class='ident'>chatbot</span>::<span class='ident'>adapter</span>::<span class='ident'>CliAdapter</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>bot</span> <span class='op'>=</span> <span class='ident'>Chatbot</span>::<span class='ident'>new</span>(<span class='string'>&quot;pingbot&quot;</span>);

<span class='kw'>let</span> <span class='ident'>ping</span> <span class='op'>=</span> <span class='macro'>handler</span><span class='macro'>!</span>(<span class='string'>&quot;PingHandler&quot;</span>, <span class='string'>r&quot;ping&quot;</span>, <span class='op'>|</span>_, _<span class='op'>|</span> <span class='prelude-val'>Some</span>(<span class='string'>&quot;pong&quot;</span>.<span class='ident'>to_owned</span>()));

<span class='ident'>bot</span>.<span class='ident'>add_addressed_handler</span>(<span class='ident'>ping</span>);
<span class='ident'>bot</span>.<span class='ident'>add_adapter</span>(<span class='ident'>CliAdapter</span>::<span class='ident'>new</span>());

<span class='ident'>bot</span>.<span class='ident'>run</span>();</pre>
</div><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table>
                    <tr class=' module-item'>
                        <td><a class='mod' href='adapter/index.html'
                               title='chatbot::adapter'>adapter</a></td>
                        <td class='docblock short'>
                             <p>Contains the <code>ChatAdapter</code> trait and several implementations</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='mod' href='handler/index.html'
                               title='chatbot::handler'>handler</a></td>
                        <td class='docblock short'>
                             <p>Contains the MessageHandler trait and handler implementations.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='mod' href='message/index.html'
                               title='chatbot::message'>message</a></td>
                        <td class='docblock short'>
                             <p>Types for incoming messages, outgoing messages, and an enum wrapper to enable control commands
for adapters.</p>

                        </td>
                    </tr>
                </table><h2 id='macros' class='section-header'><a href="#macros">Macros</a></h2>
<table>
                    <tr class=' module-item'>
                        <td><a class='macro' href='macro.handler!.html'
                               title='chatbot::handler!'>handler!</a></td>
                        <td class='docblock short'>
                             <p>The <code>handler!</code> macro is shorthand for creating simple chat handlers. It
accepts a name, a string used to build a regex for testing the incoming
message and for collecting captures, and a closure which should return a
<code>String</code> to be sent as the outgoing message.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='macro' href='macro.regex!.html'
                               title='chatbot::regex!'>regex!</a></td>
                        <td class='docblock short'>
                             <p>Shorthand for creating a <code>Regex</code> as suggested by the regex crate. You probably don&#39;t need to
<code>macro_use</code> this unless you&#39;re creating handlers in an external module.</p>

                        </td>
                    </tr>
                </table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                    <tr class=' module-item'>
                        <td><a class='struct' href='struct.Chatbot.html'
                               title='chatbot::Chatbot'>Chatbot</a></td>
                        <td class='docblock short'>
                             <p>The Chatbot is the central data structure of the chatbot platform. It contains a <code>run</code> method
which listens for messages from adapters and routes them to handlers. Any program which uses
chatbot will need to minimally create a Chatbot, add an adapter, add a handler, and call Chatbot
<a href="chatbot/struct.Chatbot.html#method.run"><code>run</code></a>.</p>

                        </td>
                    </tr>
                </table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "chatbot";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script async src="../search-index.js"></script>
</body>
</html>